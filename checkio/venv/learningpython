# Определение типа объекта
num = 13
print(type(num))
# <class 'int'> Мы определили тип объекта

# Конвертация типов объекта
num = 150.2
print(type(num))
# <class 'float'> А теперь мы ковертируем флот в интегер и проверим его тип
num = int(num)
print(num, type(num))
# И обратно
num = float(num)
print(num, type(num))

# Также мы можем работать с комплексными числами
num = 14 + 1j

print(type(num))
# Проверили комплексное ли это число
print(num.real)
# Вызвали реальную часть нашего числа
print(num.imag)
# Вызвали мнимую часть

# Также интегеры т.е. целые числа мы можем преобразовать в булеаны
print(bool(12))
# Любое положительное число больше нуля даст нам True
print(bool(0))
# По нулю мы получим значение False
print(bool(-1))
# А что если... Получается что булеан работает по модулю, отрицательное число тоже даст нам True

'''
Ненавижу строки
'''
# Мы можем складывать строки
a = "Fuck"
b = " Strings "
print(a + b)
# А еще мы можем их умножать
print((a+b) * 3)

# Адрес объекта в памяти мы можем запросить с помощью функции id()
print(id(a))
print(id(b))

# Как получить конкретные символы (в данном примере чётные) из строки с помощью step по принципу start:stop:step
example_string = "012345678"
print(example_string[3:])
# Или развернуть строку
print(example_string[::-1])

# Считаем инстансы символов в строке (ну кол-во повторений come on)
print(example_string.count("3"))
# Одна тройка блять в строке, чего непонятного

"""
Новый оператор (in), добрый вечерочек!
"""
# in позволит нам определить наличие подстроки в строке
print("3.14" in "Число Пи = 3.1415926")

"""
Ковертация флота в строку
"""
# Конвертируем в строку
num = 999.01
print(type(num))
num = str(num)
print(type(num))

# Если мы проверим непустую строку по булеану получим True, в случае пустой - False
print(bool("This string is not empty!"))
print(bool(""))

"""
Плэйсхолдеры аааааааааа
"""
template = "%s - главное достоинство программиста. (%s)"
print(template % ("Лень", "Larry Wall"))

"""
f-строки WTf (с питона 3.6)
"""
subject = "оптимизация"
author = "Donald Knuth"
print(f"Преждевременная {subject} - корень всех зол. ({author})")

# Интерактивная функция input
# name = input("Введите Ваше имя: ")
# print("Hello, " + name +"!")

# Объявление байтовой строки
example_bytes = b"hello"
print(type(example_bytes))

# Энкодинг, переводим строку в код
example_string = "привет"
print(type(example_string))
print(example_string)

encoded_string = example_string.encode(encoding="utf-8")
print(encoded_string)
print(type(encoded_string))

# А теперь декодинг
decoded_string = encoded_string.decode()
# Хоба!
print(decoded_string)

"""
Объект None
"""
answer = None
print(answer)
print(type(answer))

# None - это как ноль, только не ноль
income = 0
print(income)
if not income:
    print("Ничего не заработали")
income = None
print(income)
if income is None:
    print("Еще не начинали продавать")
elif not income:
    print("Ничего не заработали")

"""
Тернарные операторы. Мы ж тут с русским справлялись.
"""
# Пример
score_1 = 5
score_2 = 0
winner = "Argentina" if score_1 > score_2 else "Jamaica"
print(winner)

# Встроенный объект range() позволяет итерироваться по целым числам
for i in range (3):
    print(i)
# В range() также можно использовать принцип start,stop,step (только тут числа будут разделены запятой как в списке)
for i in range(5, 8):
    print(i)
for i in range(1, 10, 2):
    print(i)
# И в обратном направлении
for i in range(10, 5, -1):
    print(i)
"""
Оператор pass
"""
# Оператор pass определяет пустой блок, который ничего не делает.
for i in range(100):
    pass
"""
Оператор break... Queue Berried Alive song..
"""
# Оператор break позволяет выйти из цикла досрочно
result = 0
while True:
    result += 1
    if result >= 100:
        break
print(result)

"""
Оператор continue
"""
# Он используется, когда в блоке цикла нужно перейти к следующей итерации без выполнения оставшихся инструкций в блоке
result = 0

for i in range(10):
    if i % 2 != 0:
        continue
    result += i

print(10 / 2)

print(bool(0.000001))


# А это называется списки
empty_list = []
print(empty_list)
empty_list = list()
print(empty_list)
print(len(empty_list))


range_list = list(range(10))
print(range_list)
print(range_list[:])
# При получении среза списка мы получаем новый список
print(range_list[:] is range_list)

'''
Итерация по спискам ёпта
'''

collections = ['list', 'tuple', 'dict', 'set']
print(collections)

for collection in collections:
    print('Learning {}...'.format(collection))

# Чтобы итерироваться по индексу списка существует функция enumerate()
for idx, collection in enumerate(collections):
    print('#{} {}'.format(idx, collection))

# Добавляем в коллекцию новые элементы
collections.append('OrderedDict')
print(collections)

# Добавляем целые списки к спискам
collections.extend(['ponyset', 'unicorndict'])
print(collections)

# Также для добавления переменной в список можно использовать оператор +=
collections += [None]
print(collections)

# Оператор del позволит удалить элемент с заданным индексом
print("Delete " + collections[4])
del collections[4]
print(collections)

# Функции min, max, sum говорят сами за себя
numbers = [4, 17, 19, 9, 2, 6, 10, 13]
print(numbers)
print("The smallest value of this list is", min(numbers))
print("The biggest value of this list is ", max(numbers))
print("And the total sum of values in this list is ", sum(numbers))

# Введение кортежей. Кортежи - неизменяемые списки
empty_tuple = ()
empty_tuple = tuple()
print(empty_tuple)

# Функция sorted реаранжирует порядок элементов по указанным встроенным параметрам,
# подфункция key принимает форму указанной вами функции sorted(example_array, key=abs) и действует по отдельности на каждый элемент списка, что очень удобно

numbers_array = (-20, -5, -10, -15)
print(sorted(numbers_array, key=abs))

# Баловался с составлением списков аппендом из других списков
args = [2, 8, 3, 4]
print(args)
le_array = []
print(le_array)
for i in args:
    le_array.append(i)
print(le_array)
le_array = sorted(le_array)
print(le_array)



